#!/bin/zsh

. ~/bin/f4pga.sh

dev=xc7z010_test
family=zynq7
part=xc7z010clg400-1
xdc=
sdc=
pcf=
fargs=()
vh=()
top=top
bn=
int=()

ad() {
  case "$1" in
    /*) f="$1" ;;
    *)  f="$PWD/$1" ;;
  esac
}

addf() {
  ad "$2"
  fargs=("${fargs[@]}" $1 "$f")
}

addd() {
  fargs=(-v "$1" -s "$1" "${fargs[@]}")
}

while [ $# -gt 0 ]; do
  case "$1" in
    *.v) addf -v "$1" ;;
    *.sv) addf -s "$1" ;;
    *.vhd|*.vhdl) ad "$1"; vh=("${vh[@]}" "$f") ;;
    *.xdc) bn="${1%.*}"; bn="${bn##*/}"; addf -x "$1" ;;
    *.sdc) ad "$1"; sdc="$f" ;;
    *.pcf) ad "$1"; pcf="$f" ;;
    *.int) ad "$1"; int=("${int[@]}" "$f") ;;
    -t) shift; top="$1" ;;
    -D) shift; addd "-D$1" ;;
    -D*) addd "$1" ;;
  esac
  shift
done

mkdir -p build-"$bn"
cd build-"$bn"
set -e

if [ -n "$vh" ]; then
  if [ -f work-obj08.cf ]; then
    for x in "${vh[@]}"; do
      test "$x" -ot work-obj08.cf && continue
      rm -f work-obj08.cf
      break
    done
  fi
  test -f work-obj08.cf || ghdl -i --std=08 --ieee=synopsys "${vh[@]}"
  if [ ! -f vhdl.v -o work-obj08.cf -nt vhdl.v ]; then
    echo "Converting VHDL to Verilog"
    touch vhdl.v
    fn=
    while read -r t i f i i l i; do
      case "$t" in
        file) eval fn="$f" ;;
	architecture)
	  l="${l%\(}"
	  tail -n +$l "$fn" | head -n 1 | while read i i i n i; do
	    /usr/local/bin/yosys -m ghdl -o vhdl.v \
	          -p "ghdl --std=08 --ieee=synopsys --latches ${vh[*]} -e $n" \
		  -p "hierarchy -top $n" -p flatten -p "read_verilog vhdl.v"
	  done
	  ;;
      esac
    done <work-obj08.cf
  fi
  fargs=("${fargs[@]}" -v vhdl.v)
fi

test -z "$bn" && bn="$top"

export VPR_NUM_WORKERS=9

set -- "${fargs[@]}"
while [ "$#" -gt 0 ]; do
  x="$1"; shift
  case "$x" in
    -D*) continue ;;
    *) f="$1"; shift; test "$f" -ot "$top".eblif && continue || : ;;
  esac
  echo "Synthesizing"
  symbiflow_synth -t "$top" "${fargs[@]}" -d $family -p $part
done
echo "Pack"
test "$top".eblif -nt "$top".net || \
  symbiflow_pack -e "$top".eblif -d $dev ${sdc:+-s "$sdc"}
echo "Place"
test "$top".net -nt "$top".place || \
  symbiflow_place -e "$top".eblif -d $dev -P $part -n "$top".net \
    ${sdc:+-s "$sdc"} ${pcf:+-p "$pcf"}
echo "Route"
test "$top".place -ot "$top".route || \
  symbiflow_route -e "$top".eblif -d $dev ${sdc:+-s "$sdc"}
echo "Fasm"
test "$top".route -ot "$top".fasm || \
  symbiflow_write_fasm -e "$top".eblif -d $dev
echo "Bin"
test "$top".fasm -ot "$top".bit || \
  symbiflow_write_bitstream -d $family -f "$top".fasm -p $part -b "$top".bit

exit 0
cat <<EOF >boot.bif
all: {
// [bootimage] part // part is a generated boot image
  [bootloader] fsbl.elf
  [alignment=64] u-boot.elf
  [init] ebaz.int
EOF
for x in "${int[@]}"; do
  echo "  [init] \"$x\"" >>boot.bif
done
echo "}" >>boot.bif
# Default register inits: clocks, ethernet, SD, UART1
cat <<EOF >ebaz.int
//  .set. 0xF8000120 = 0x1F000200;
//  note: expressions, decimal #s are allowed.
//  ... up to 256 register inits
EOF
bootgen -arch zynq -image boot.bif -o boot.bin
